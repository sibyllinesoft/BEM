name: Security

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]
  schedule:
    # Run weekly security scans on Mondays at 3 AM UTC
    - cron: '0 3 * * 1'
  workflow_dispatch:
    inputs:
      scan_type:
        description: 'Type of security scan'
        required: true
        default: 'full'
        type: choice
        options:
          - full
          - dependencies
          - code
          - secrets

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  FORCE_COLOR: 1
  PIP_DISABLE_PIP_VERSION_CHECK: 1

jobs:
  # Dependency vulnerability scanning
  dependency-scan:
    name: Dependency Vulnerability Scan
    runs-on: ubuntu-latest
    if: github.event.inputs.scan_type != 'code' && github.event.inputs.scan_type != 'secrets'
    timeout-minutes: 15
    permissions:
      security-events: write
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Install security tools
        run: |
          python -m pip install --upgrade pip
          pip install safety pip-audit cyclonedx-bom

      - name: Generate requirements lock file
        run: |
          pip install -r requirements.txt
          pip freeze > requirements-lock.txt

      - name: Safety vulnerability check
        run: |
          safety check --json --output safety-report.json || true
          safety check --output safety-report.txt || true

      - name: Pip-audit vulnerability check
        run: |
          pip-audit --format=json --output=pip-audit-report.json || true
          pip-audit --format=text --output=pip-audit-report.txt || true

      - name: Generate SBOM (Software Bill of Materials)
        run: |
          cyclonedx-py -r -f json -o sbom.json .

      - name: Check for high-severity vulnerabilities
        run: |
          python << EOF
          import json
          import sys
          
          # Check safety report
          try:
              with open('safety-report.json', 'r') as f:
                  safety_data = json.load(f)
              
              high_severity = 0
              if isinstance(safety_data, list):
                  for vuln in safety_data:
                      # Count high severity vulnerabilities
                      if 'vulnerability' in str(vuln).lower():
                          high_severity += 1
              
              print(f"Safety scan found {high_severity} vulnerabilities")
              
          except (FileNotFoundError, json.JSONDecodeError):
              print("Safety report not found or invalid")
          
          # Check pip-audit report
          try:
              with open('pip-audit-report.json', 'r') as f:
                  audit_data = json.load(f)
              
              audit_vulns = len(audit_data.get('vulnerabilities', []))
              print(f"Pip-audit found {audit_vulns} vulnerabilities")
              
              # Exit with error if high-severity vulnerabilities found
              if high_severity > 5 or audit_vulns > 10:
                  print("‚ö†Ô∏è High number of vulnerabilities detected!")
                  print("Please review and address critical security issues.")
                  sys.exit(1)
              
          except (FileNotFoundError, json.JSONDecodeError):
              print("Pip-audit report not found or invalid")
          EOF

      - name: Upload dependency scan results
        uses: actions/upload-artifact@v3
        if: always()
        with:
          name: dependency-scan-results
          path: |
            safety-report.*
            pip-audit-report.*
            sbom.json
            requirements-lock.txt
          retention-days: 30

  # Static code security analysis
  code-scan:
    name: Static Code Analysis
    runs-on: ubuntu-latest
    if: github.event.inputs.scan_type != 'dependencies' && github.event.inputs.scan_type != 'secrets'
    timeout-minutes: 20
    permissions:
      security-events: write
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Install security analysis tools
        run: |
          python -m pip install --upgrade pip
          pip install bandit[toml] semgrep pylint-secure

      - name: Bandit security linting
        run: |
          bandit -r src/ -f json -o bandit-report.json -ll
          bandit -r src/ -f txt -o bandit-report.txt -ll
          
          # Also check scripts and tests for basic issues
          bandit -r scripts/ tests/ -f json -o bandit-scripts-report.json -ll || true

      - name: Semgrep security scan
        run: |
          # Install semgrep if not available
          pip install semgrep
          
          # Run comprehensive security rules
          semgrep --config=auto --json --output=semgrep-report.json src/ || true
          semgrep --config=auto --output=semgrep-report.txt src/ || true
          
          # Run specific Python security rules
          semgrep --config=p/python --json --output=semgrep-python-report.json src/ || true

      - name: Custom security checks
        run: |
          python << 'EOF'
          import os
          import re
          import json
          from pathlib import Path
          
          security_issues = []
          
          # Check for common security anti-patterns
          patterns = {
              'hardcoded_secrets': r'(password|secret|key|token)\s*=\s*["\'][^"\']+["\']',
              'sql_injection': r'\.execute\s*\(\s*["\'].*%.*["\']',
              'command_injection': r'os\.system\s*\(\s*.*\+',
              'unsafe_yaml': r'yaml\.load\s*\(',
              'unsafe_pickle': r'pickle\.loads?\s*\(',
              'eval_usage': r'\beval\s*\(',
              'exec_usage': r'\bexec\s*\(',
          }
          
          for py_file in Path('src').rglob('*.py'):
              with open(py_file, 'r', encoding='utf-8', errors='ignore') as f:
                  content = f.read()
                  
              for pattern_name, pattern in patterns.items():
                  matches = re.finditer(pattern, content, re.IGNORECASE)
                  for match in matches:
                      line_num = content[:match.start()].count('\n') + 1
                      security_issues.append({
                          'file': str(py_file),
                          'line': line_num,
                          'issue': pattern_name,
                          'code': match.group(0).strip()
                      })
          
          # Save custom security scan results
          with open('custom-security-scan.json', 'w') as f:
              json.dump(security_issues, f, indent=2)
          
          print(f"Custom security scan found {len(security_issues)} potential issues")
          
          # Print summary
          if security_issues:
              print("\nSecurity issues found:")
              for issue in security_issues[:5]:  # Show first 5
                  print(f"  {issue['file']}:{issue['line']} - {issue['issue']}")
              if len(security_issues) > 5:
                  print(f"  ... and {len(security_issues) - 5} more")
          EOF

      - name: Security scan summary
        run: |
          echo "## Security Scan Summary" > security-summary.md
          echo "" >> security-summary.md
          
          # Count issues from different tools
          BANDIT_ISSUES=$(jq '.results | length' bandit-report.json 2>/dev/null || echo "0")
          SEMGREP_ISSUES=$(jq '.results | length' semgrep-report.json 2>/dev/null || echo "0")
          CUSTOM_ISSUES=$(jq '. | length' custom-security-scan.json 2>/dev/null || echo "0")
          
          echo "- **Bandit Issues:** $BANDIT_ISSUES" >> security-summary.md
          echo "- **Semgrep Issues:** $SEMGREP_ISSUES" >> security-summary.md
          echo "- **Custom Scan Issues:** $CUSTOM_ISSUES" >> security-summary.md
          echo "" >> security-summary.md
          
          TOTAL_ISSUES=$((BANDIT_ISSUES + SEMGREP_ISSUES + CUSTOM_ISSUES))
          echo "- **Total Issues:** $TOTAL_ISSUES" >> security-summary.md
          
          if [ "$TOTAL_ISSUES" -gt 20 ]; then
            echo "‚ö†Ô∏è High number of security issues detected!" >> security-summary.md
            echo "Please review and address critical security findings." >> security-summary.md
          fi
          
          cat security-summary.md

      - name: Upload code scan results
        uses: actions/upload-artifact@v3
        if: always()
        with:
          name: code-scan-results
          path: |
            bandit-report.*
            bandit-scripts-report.*
            semgrep-report.*
            semgrep-python-report.*
            custom-security-scan.json
            security-summary.md
          retention-days: 30

  # Secret detection
  secret-scan:
    name: Secret Detection
    runs-on: ubuntu-latest
    if: github.event.inputs.scan_type != 'dependencies' && github.event.inputs.scan_type != 'code'
    timeout-minutes: 15

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for secret detection

      - name: TruffleHog secret detection
        uses: trufflesecurity/trufflehog@main
        with:
          path: ./
          base: main
          head: HEAD
          extra_args: --debug --only-verified

      - name: GitLeaks secret detection
        uses: gitleaks/gitleaks-action@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          config-path: .gitleaks.toml

      - name: Create GitLeaks config if missing
        run: |
          if [[ ! -f .gitleaks.toml ]]; then
            cat > .gitleaks.toml << 'EOF'
          title = "BEM GitLeaks Configuration"
          
          [extend]
          useDefault = true
          
          [[rules]]
          description = "AWS Access Key"
          id = "aws-access-key"
          regex = '''(A3T[A-Z0-9]|AKIA|AGPA|AIDA|AROA|AIPA|ANPA|ANVA|ASIA)[A-Z0-9]{16}'''
          tags = ["key", "AWS"]
          
          [[rules]]
          description = "OpenAI API Key"
          id = "openai-api-key"
          regex = '''sk-[a-zA-Z0-9]{48}'''
          tags = ["key", "OpenAI"]
          
          [[rules]]
          description = "Private Key"
          id = "private-key"
          regex = '''-----BEGIN (RSA |OPENSSH |DSA |EC |PGP )?PRIVATE KEY-----'''
          tags = ["key", "private"]
          
          [allowlist]
          description = "Allowlisted files"
          files = [
            '''\.git/.*''',
            '''tests/.*''',
            '''examples/.*''',
            '''docs/.*'''
          ]
          
          paths = [
            '''gitleaks\.toml''',
            '''\.github/workflows/.*'''
          ]
          EOF
          fi

      - name: Custom secret patterns
        run: |
          python << 'EOF'
          import re
          import json
          from pathlib import Path
          
          # Custom patterns for ML/AI specific secrets
          patterns = {
              'huggingface_token': r'hf_[a-zA-Z0-9]{34}',
              'wandb_api_key': r'[a-f0-9]{40}',  # WandB API keys
              'comet_api_key': r'[a-zA-Z0-9]{32}',  # Comet ML API keys
              'mlflow_token': r'mlflow_[a-zA-Z0-9]{32}',
              'generic_api_key': r'api[_-]?key["\']?\s*[:=]\s*["\'][a-zA-Z0-9]{32,}["\']',
              'database_url': r'(postgresql|mysql|mongodb)://[^:\s]+:[^@\s]+@[^:\s]+:\d+/\w+',
          }
          
          secrets_found = []
          
          # Search through source files
          for pattern_name, pattern in patterns.items():
              for py_file in Path('.').rglob('*.py'):
                  if 'test' in str(py_file) or '.git' in str(py_file):
                      continue
                      
                  try:
                      with open(py_file, 'r', encoding='utf-8', errors='ignore') as f:
                          content = f.read()
                      
                      matches = re.finditer(pattern, content, re.IGNORECASE)
                      for match in matches:
                          line_num = content[:match.start()].count('\n') + 1
                          secrets_found.append({
                              'file': str(py_file),
                              'line': line_num,
                              'type': pattern_name,
                              'match': match.group(0)[:50] + '...'  # Truncate for safety
                          })
                  except:
                      continue
          
          # Also check config files
          for config_file in ['config.yaml', 'config.json', '.env', '.env.local']:
              if Path(config_file).exists():
                  try:
                      with open(config_file, 'r', encoding='utf-8') as f:
                          content = f.read()
                      
                      for pattern_name, pattern in patterns.items():
                          matches = re.finditer(pattern, content, re.IGNORECASE)
                          for match in matches:
                              line_num = content[:match.start()].count('\n') + 1
                              secrets_found.append({
                                  'file': config_file,
                                  'line': line_num,
                                  'type': pattern_name,
                                  'match': match.group(0)[:50] + '...'
                              })
                  except:
                      continue
          
          # Save results
          with open('custom-secret-scan.json', 'w') as f:
              json.dump(secrets_found, f, indent=2)
          
          print(f"Custom secret scan found {len(secrets_found)} potential secrets")
          
          if secrets_found:
              print("\nPotential secrets found:")
              for secret in secrets_found[:3]:  # Show first 3
                  print(f"  {secret['file']}:{secret['line']} - {secret['type']}")
          EOF

      - name: Upload secret scan results
        uses: actions/upload-artifact@v3
        if: always()
        with:
          name: secret-scan-results
          path: |
            custom-secret-scan.json
            .gitleaks.toml
          retention-days: 30

  # Container security scan (if Dockerfile exists)
  container-scan:
    name: Container Security Scan
    runs-on: ubuntu-latest
    if: github.event.inputs.scan_type == 'full' || github.event_name == 'schedule'
    timeout-minutes: 20

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Check for Dockerfile
        id: dockerfile
        run: |
          if [[ -f Dockerfile ]]; then
            echo "dockerfile_exists=true" >> $GITHUB_OUTPUT
          else
            echo "dockerfile_exists=false" >> $GITHUB_OUTPUT
            echo "No Dockerfile found, creating basic one for scanning..."
            cat > Dockerfile << 'EOF'
          FROM python:3.11-slim
          
          WORKDIR /app
          
          COPY requirements.txt .
          RUN pip install --no-cache-dir -r requirements.txt
          
          COPY src/ ./src/
          RUN pip install -e .
          
          CMD ["python", "-m", "bem_core"]
          EOF
          fi

      - name: Build Docker image
        if: steps.dockerfile.outputs.dockerfile_exists == 'true' || github.event_name == 'schedule'
        run: |
          docker build -t bem:security-scan .

      - name: Run Trivy container scan
        if: steps.dockerfile.outputs.dockerfile_exists == 'true' || github.event_name == 'schedule'
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: 'bem:security-scan'
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: Upload Trivy scan results to GitHub Security
        if: (steps.dockerfile.outputs.dockerfile_exists == 'true' || github.event_name == 'schedule') && github.event_name != 'pull_request'
        uses: github/codeql-action/upload-sarif@v2
        with:
          sarif_file: 'trivy-results.sarif'

      - name: Upload container scan results
        uses: actions/upload-artifact@v3
        if: always()
        with:
          name: container-scan-results
          path: |
            trivy-results.sarif
            Dockerfile
          retention-days: 30

  # Security policy compliance check
  compliance-check:
    name: Security Policy Compliance
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Check security policy files
        run: |
          echo "## Security Policy Compliance Check" > compliance-report.md
          echo "" >> compliance-report.md
          
          # Check for required security files
          if [[ -f SECURITY.md ]]; then
            echo "‚úÖ SECURITY.md exists" >> compliance-report.md
          else
            echo "‚ùå SECURITY.md missing" >> compliance-report.md
          fi
          
          if [[ -f CODE_OF_CONDUCT.md ]]; then
            echo "‚úÖ CODE_OF_CONDUCT.md exists" >> compliance-report.md
          else
            echo "‚ùå CODE_OF_CONDUCT.md missing" >> compliance-report.md
          fi
          
          if [[ -f .github/dependabot.yml ]]; then
            echo "‚úÖ Dependabot configuration exists" >> compliance-report.md
          else
            echo "‚ùå Dependabot configuration missing" >> compliance-report.md
          fi
          
          # Check for secure coding practices in pyproject.toml
          if grep -q "bandit" pyproject.toml; then
            echo "‚úÖ Bandit security linting configured" >> compliance-report.md
          else
            echo "‚ùå Bandit security linting not configured" >> compliance-report.md
          fi
          
          echo "" >> compliance-report.md
          echo "**Generated:** $(date)" >> compliance-report.md
          
          cat compliance-report.md

      - name: Upload compliance report
        uses: actions/upload-artifact@v3
        with:
          name: compliance-report
          path: compliance-report.md
          retention-days: 30

  # Security summary and reporting
  security-summary:
    name: Security Summary
    runs-on: ubuntu-latest
    needs: [dependency-scan, code-scan, secret-scan, container-scan, compliance-check]
    if: always()
    timeout-minutes: 10

    steps:
      - name: Download all scan results
        uses: actions/download-artifact@v3
        with:
          path: security-results/

      - name: Generate comprehensive security report
        run: |
          echo "# üõ°Ô∏è Security Scan Summary Report" > security-report.md
          echo "" >> security-report.md
          echo "**Scan Date:** $(date)" >> security-report.md
          echo "**Repository:** ${{ github.repository }}" >> security-report.md
          echo "**Commit:** ${{ github.sha }}" >> security-report.md
          echo "" >> security-report.md
          
          # Scan results summary
          echo "## Scan Results" >> security-report.md
          echo "" >> security-report.md
          echo "| Scan Type | Status | Issues |" >> security-report.md
          echo "|-----------|--------|--------|" >> security-report.md
          echo "| Dependencies | ${{ needs.dependency-scan.result == 'success' && '‚úÖ Passed' || needs.dependency-scan.result == 'skipped' && '‚è≠Ô∏è Skipped' || '‚ùå Failed' }} | - |" >> security-report.md
          echo "| Code Analysis | ${{ needs.code-scan.result == 'success' && '‚úÖ Passed' || needs.code-scan.result == 'skipped' && '‚è≠Ô∏è Skipped' || '‚ùå Failed' }} | - |" >> security-report.md
          echo "| Secret Detection | ${{ needs.secret-scan.result == 'success' && '‚úÖ Passed' || needs.secret-scan.result == 'skipped' && '‚è≠Ô∏è Skipped' || '‚ùå Failed' }} | - |" >> security-report.md
          echo "| Container Security | ${{ needs.container-scan.result == 'success' && '‚úÖ Passed' || needs.container-scan.result == 'skipped' && '‚è≠Ô∏è Skipped' || '‚ùå Failed' }} | - |" >> security-report.md
          echo "| Policy Compliance | ${{ needs.compliance-check.result == 'success' && '‚úÖ Passed' || needs.compliance-check.result == 'skipped' && '‚è≠Ô∏è Skipped' || '‚ùå Failed' }} | - |" >> security-report.md
          echo "" >> security-report.md
          
          # Recommendations
          echo "## Recommendations" >> security-report.md
          echo "" >> security-report.md
          echo "- üîÑ Keep dependencies updated regularly" >> security-report.md
          echo "- üîê Use secrets management for sensitive data" >> security-report.md
          echo "- üèóÔ∏è Follow secure coding practices" >> security-report.md
          echo "- üìã Review and address high-severity findings" >> security-report.md
          echo "- üõ°Ô∏è Enable security alerts and monitoring" >> security-report.md
          echo "" >> security-report.md
          
          # Next steps
          echo "## Next Steps" >> security-report.md
          echo "" >> security-report.md
          echo "1. Review detailed scan results in artifacts" >> security-report.md
          echo "2. Address critical and high-severity issues" >> security-report.md
          echo "3. Update security documentation" >> security-report.md
          echo "4. Schedule regular security reviews" >> security-report.md
          
          cat security-report.md

      - name: Upload security summary
        uses: actions/upload-artifact@v3
        with:
          name: security-summary-report
          path: security-report.md
          retention-days: 90

      - name: Security scan status
        run: |
          FAILED_JOBS=0
          
          [[ "${{ needs.dependency-scan.result }}" == "failure" ]] && ((FAILED_JOBS++))
          [[ "${{ needs.code-scan.result }}" == "failure" ]] && ((FAILED_JOBS++))
          [[ "${{ needs.secret-scan.result }}" == "failure" ]] && ((FAILED_JOBS++))
          [[ "${{ needs.container-scan.result }}" == "failure" ]] && ((FAILED_JOBS++))
          [[ "${{ needs.compliance-check.result }}" == "failure" ]] && ((FAILED_JOBS++))
          
          echo "Security scan completed with $FAILED_JOBS failed jobs"
          
          if [ "$FAILED_JOBS" -gt 2 ]; then
            echo "‚ö†Ô∏è Multiple security scans failed - immediate review recommended"
            exit 1
          elif [ "$FAILED_JOBS" -gt 0 ]; then
            echo "‚ö†Ô∏è Some security issues detected - review recommended"
          else
            echo "‚úÖ All security scans passed successfully"
          fi